Coroutine is destroyed (by terminating via co_return an uncaught exception, or via the
coroutine handle)
- calls the destruction of the promise object
- calls the destructor of the function parameters 
- frees the memory used by the coroutine frame 
- transfers control back to the caller

When a coroutine ends with an uncaught exception, the following happens:
- catches the exception and calls prom.unhandled_exception() from the catch block
- calls prom.final_suspend() and co_awaits the result

When you use co_await expr in a coroutine, or the compiler implicitly invokes co_await prom.initial_suspend(), co_await prom.final.suspend(), or co_await prom.yield_value(value), a second, inner awaitable workflow starts.

